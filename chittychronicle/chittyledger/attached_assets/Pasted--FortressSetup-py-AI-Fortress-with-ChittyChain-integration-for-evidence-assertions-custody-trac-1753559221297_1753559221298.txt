# FortressSetup.py
# AI Fortress with ChittyChain integration for evidence, assertions, custody tracking, and GitHub sync

import uvicorn
from fastapi import FastAPI, Header, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from pydantic import BaseModel
import subprocess
import uuid
import os
import hashlib
import logging
import requests
import time
import json
from datetime import datetime
import psycopg2
from sqlalchemy import create_engine, text

TRUSTED_INPUT_DIR = "./opt/fortress/input"
TRUSTED_OUTPUT_DIR = "./opt/fortress/output"
SANDBOX_DIR = "./opt/fortress/vault"
AUDITOR_LOG = "./opt/fortress/audit.log"
CHAIN_LOG = "./opt/fortress/chitty_chain.ndjson"
PGP_KEY_ID = "YOUR_PGP_KEY_ID"
FORTRESS_API = "http://localhost:8000"
OPENAI_GATEKEEPER_KEY = "TRUSTED_GATEWAY_KEY"
ASSERTIONS_LOG = "./opt/fortress/assertions.ndjson"
STATIC_DIR = "./static"
GIT_REPO_DIR = "./"
GIT_COMMIT_USER = "fortress-bot"
GIT_COMMIT_EMAIL = "bot@chitty.cc"

# DB integration
DATABASE_URL = os.getenv('CHITTY_DATABASE_URL')
engine = create_engine(DATABASE_URL)

os.makedirs(TRUSTED_INPUT_DIR, exist_ok=True)
os.makedirs(TRUSTED_OUTPUT_DIR, exist_ok=True)
os.makedirs(SANDBOX_DIR, exist_ok=True)
os.makedirs(STATIC_DIR, exist_ok=True)

logging.basicConfig(filename=AUDITOR_LOG, level=logging.INFO, format='%(asctime)s %(message)s')

app = FastAPI()
app.mount("/static", StaticFiles(directory=STATIC_DIR), name="static")

class InputPayload(BaseModel):
    content: str
    label: str

class AgentJob(BaseModel):
    prompt: str
    label: str

class Assertion(BaseModel):
    subject: str
    predicate: str
    object: str
    source: str
    timestamp: float

def sha256sum(content: str) -> str:
    return hashlib.sha256(content.encode()).hexdigest()

def sign_output(filepath: str):
    try:
        subprocess.run([
            "gpg", "--default-key", PGP_KEY_ID,
            "--output", filepath + ".sig",
            "--detach-sign", filepath
        ], check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"GPG signing failed: {e}")

def log_atomic_fact(assertion: Assertion):
    fact_id = hashlib.sha256((assertion.subject + assertion.predicate + assertion.object + assertion.source + str(assertion.timestamp)).encode()).hexdigest()
    fact = {
        "uuid": fact_id,
        "subject": assertion.subject,
        "predicate": assertion.predicate,
        "object": assertion.object,
        "source": assertion.source,
        "timestamp": assertion.timestamp,
        "ingested_at": time.time()
    }
    with open(CHAIN_LOG, "a") as f:
        f.write(json.dumps(fact) + "\n")
    commit_chain_log()
    return fact_id

def commit_chain_log():
    try:
        subprocess.run(["git", "config", "user.name", GIT_COMMIT_USER], cwd=GIT_REPO_DIR)
        subprocess.run(["git", "config", "user.email", GIT_COMMIT_EMAIL], cwd=GIT_REPO_DIR)
        subprocess.run(["git", "add", CHAIN_LOG], cwd=GIT_REPO_DIR)
        commit_message = f"chitty_chain update {datetime.now().isoformat()}"
        subprocess.run(["git", "commit", "-m", commit_message], cwd=GIT_REPO_DIR)
        subprocess.run(["git", "push"], cwd=GIT_REPO_DIR)
        logging.info(f"[GIT_COMMIT] {commit_message}")
    except subprocess.CalledProcessError as e:
        logging.error(f"Git commit failed: {e}")

@app.post("/ingest")
async def ingest(payload: InputPayload, x_api_key: str = Header(...)):
    if x_api_key != OPENAI_GATEKEEPER_KEY:
        raise HTTPException(status_code=403, detail="Unauthorized")

    input_id = str(uuid.uuid4())
    filename = os.path.join(TRUSTED_INPUT_DIR, f"{input_id}.txt")
    with open(filename, "w") as f:
        f.write(payload.content)

    logging.info(f"[INGESTED] ID={input_id} Label={payload.label} SHA256={sha256sum(payload.content)}")
    return {"status": "stored", "input_id": input_id}

@app.post("/run/{input_id}")
async def run_agent(input_id: str):
    infile = os.path.join(TRUSTED_INPUT_DIR, f"{input_id}.txt")
    outfile = os.path.join(TRUSTED_OUTPUT_DIR, f"{input_id}_out.txt")

    if not os.path.exists(infile):
        raise HTTPException(status_code=404, detail="Input not found")

    try:
        subprocess.run([
            "docker", "run", "--rm", "--network=none",
            "-v", f"{os.path.abspath(infile)}:/vault/input.txt:ro",
            "-v", f"{os.path.abspath(outfile)}:/vault/output.txt",
            "ai-agent:latest"
        ], check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"Docker execution failed: {e}")
        raise HTTPException(status_code=500, detail="Agent failed")

    with open(outfile, "r") as out:
        hashed = sha256sum(out.read())

    sign_output(outfile)
    logging.info(f"[AGENT_RUN] ID={input_id} OUT_SHA256={hashed}")

    # Store in database
    with engine.connect() as conn:
        conn.execute(text("""
            INSERT INTO secure_executions (fortress_job_id, prompt, prompt_hash, security_level, execution_method, status, fortress_output, fortress_signature)
            VALUES (:job_id, 'external', 'external', 'fortress', 'sandboxed', 'completed', :output, :signature)
        """), {
            "job_id": input_id,
            "output": open(outfile).read(),
            "signature": open(outfile + ".sig").read()
        })
        conn.commit()

    return {"status": "done", "output_file": f"{input_id}_out.txt"}

@app.get("/output/{output_file}")
async def fetch_output(output_file: str):
    filepath = os.path.join(TRUSTED_OUTPUT_DIR, output_file)
    sigpath = filepath + ".sig"

    if not os.path.exists(filepath):
        raise HTTPException(status_code=404, detail="Output not found")

    with open(filepath) as f:
        content = f.read()
    with open(sigpath) as f:
        signature = f.read()

    return {"output": content, "signature": signature, "verified_by": PGP_KEY_ID}

@app.post("/go-between")
async def go_between(job: AgentJob):
    headers = {"x-api-key": OPENAI_GATEKEEPER_KEY}
    payload = {"content": job.prompt, "label": job.label}

    try:
        ingest_res = requests.post(f"{FORTRESS_API}/ingest", json=payload, headers=headers)
        ingest_res.raise_for_status()
        input_id = ingest_res.json().get("input_id")

        run_res = requests.post(f"{FORTRESS_API}/run/{input_id}")
        run_res.raise_for_status()
        out_file = run_res.json().get("output_file")

        output_res = requests.get(f"{FORTRESS_API}/output/{out_file}")
        output_res.raise_for_status()
        return output_res.json()

    except Exception as e:
        logging.error(f"[GO-BETWEEN ERROR] {str(e)}")
        raise HTTPException(status_code=500, detail="Go-Between failed")

@app.post("/assert")
async def log_assertion(assertion: Assertion):
    try:
        fact_id = log_atomic_fact(assertion)
        with open(ASSERTIONS_LOG, "a") as f:
            f.write(assertion.json() + "\n")
        logging.info(f"[ASSERTION] {assertion.subject} {assertion.predicate} {assertion.object} SOURCE={assertion.source}")
        return {"status": "recorded", "timestamp": assertion.timestamp, "fact_id": fact_id}
    except Exception as e:
        logging.error(f"[ASSERTION ERROR] {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to record assertion")

@app.get("/")
async def index():
    return FileResponse(os.path.join(STATIC_DIR, "index.html"))

if __name__ == "__main__":
    uvicorn.run("FortressSetup:app", host="0.0.0.0", port=8000, reload=True)
